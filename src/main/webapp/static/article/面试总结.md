# 面试准备
标签（空格分隔）： 面试

---

[git面试整理资料](https://hit-alibaba.github.io/interview/index.html)


j2se基础：
##一、 九种基本数据类型，封装类。
1. byte:
>byte数据类型是8位、有符号的，以二进制补码表示的整数。（-2^7 ~ 2^7-1），默认值0，byte类型用在大型数组中节约空间，主要代替整数，因为byte变量占用的空间只有int类型的四分之一。


2. short：
>short数据类型是16位，有符号的以二进制补码表示的整数。最小值-32768（-2^15） ~ -32767（2^15-1）；short数据类型也可以像byte那样节省空间，一个short变量是int变量所占空间的二分之一。默认值0.

3. int：
>int数据类型是32位，有符号是以二进制补码表示的整数最小值（-2^31 ~ 2^31-1）
默认值0

4. long
>long数据类型是64位，有符号的以二进制补码表示的整数；
（-2^63 ~ 2^63-1） 这种类型主要使用在需要比较大整数的系统上默认值是0L，

5. float:
>float数据类型是单精度、32位的。
float在存储大型浮点数组的时候课节省内存空间，默认值0.0f;

6. double:
>double数据类型是双精度、64位；
浮点数的默认类型是double类型；默认值0.0d;

7. boolean:
>boolean表示一位的信息；只有两个取值。默认值false；

8. char：
>char类型是一个单一的16位Unicode字符，最小值"\u0000"即为0，最大值是"\uffff"65535
char可以存储任何字符。


## 二、 Switch能否用string做参数？
>在java7以后switch开始支持String类型；
不能作为switch的参数的有：boolean，float,double,long(不能直接转换为int)；
可以作为switch的参数：能够自动转换为整型的数据类型byte,short,int,String类型，枚举类型。
Switch和if-else区别：
if...else每个条件都计算一遍，除非是if-else的第一个条件就为true。
switch 是有符合条件的就跳出。
总结：当只有分支比较少的时候，if效率比switch高（因为switch有跳转表） 分支比较多，那当然是switch 。
（switch和if-else最好都要少用，为了后期维护的方便，应该复合开闭原则）

## 三、 equals 和 == 区别
>1. ==是判断两个变量或实例是不是指向同一个内存空间equals是判断两个变量或实例所指向的内存空间的值是不是相同.
2. ==是指对内存地址进行比较,equals()是对字符串的内容进行比较.
3. ==指引用是否相同,equals()指的是值是否相同.
补充：
* 如果比较对象是值变量，只用==那么equals是不存在的。
* Object里的equals的实现就是直接调用了==操作，如果你定义一个类，继承object并没有覆盖equals的方法，那么两个就是一样的。
* 如果一个类重写过equals方法或者继承自一个重写过equals方法的类，那么效果与==操作就不一样了

## 四、 Object有哪些公用方法？
>1. clone方法
保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。
主要是JAVA里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递，我们有时候不希望在方法里讲参数改变，这是就需要在类中复写clone方法。
2. getClass方法
final方法，获得运行时类型。
3. toString方法
该方法用得比较多，一般子类都有覆盖。
4. finalize方法
该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。
5. equals方法
该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。
6. hashCode方法
该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。
一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。
如果不重写hashcode(),在HashSet中添加两个equals的对象，会将两个对象都加入进去。
7. wait方法
wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。
调用该方法后当前线程进入睡眠状态，直到以下事件发生。
（1）其他线程调用了该对象的notify方法。
（2）其他线程调用了该对象的notifyAll方法。
（3）其他线程调用了interrupt中断该线程。
（4）时间间隔到了。
此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。
8. notify方法
该方法唤醒在该对象上等待的某个线程。
9. notifyAll方法
该方法唤醒在该对象上等待的所有线程。

## 五、 Java的四种引用，强弱软虚，用到的场景。


>1. 强引用
 以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于必不可少的生活用品，**垃圾回收器绝不会回收它**。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。
2. 软引用（SoftReference）
如果一个对象只具有软引用，那就类似于可有可物的生活用品。**如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。**只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。
   软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。
3. 弱引用（WeakReference）
    如果一个对象只具有弱引用，那就类似于可有可物的生活用品。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，**一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。**不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。 
    弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。
4. 虚引用（PhantomReference）
    "虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。**如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。**
    虚引用主要用来跟踪对象被垃圾回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时**，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。**程序可以通过判断引用队列中是 否已经加入了虚引用，来了解
被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。


## 六、 Hashcode的作用
官方定义：
>hashcode方法返回该对象的哈希码值。支持该方法是为哈希表提供一些优点，例如，java.util.Hashtable 提供的哈希表。   

hashCode 的常规协定是：   
>在 Java 应用程序执行期间，在同一对象上多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是对象上 equals 比较中所用的信息没有被修改。从某一应用程序的一次执行到同一应用程序的另一次执行，该整数无需保持一致。   
    如果根据 equals(Object) 方法，两个对象是相等的，那么在两个对象中的每个对象上调用 hashCode 方法都必须生成相同的整数结果。   
    以下情况不 是必需的：如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么在两个对象中的任一对象上调用 hashCode 方法必定会生成不同的整数结果。但是，程序员应该知道，为不相等的对象生成不同整数结果可以提高哈希表的性能。   
    实际上，由 Object 类定义的 hashCode 方法确实会针对不同的对象返回不同的整数。（这一般是通过将该对象的内部地址转换成一个整数来实现的，但是 JavaTM 编程语言不需要这种实现技巧。）   
      
    当equals方法被重写时，通常有必要重写 hashCode 方法，以维护 hashCode 方法的常规协定，该协定声明相等对象必须具有相等的哈希码。  
    
    
以上这段官方文档的定义，我们可以抽出成以下几个关键点：

>1. hashCode的存在主要是用于查找的快捷性，如Hashtable，HashMap等，hashCode是用来在散列存储结构中确定对象的存储地址的；
2. 如果两个对象相同，就是适用于equals(Java.lang.Object) 方法，那么这两个对象的hashCode一定要相同；
3. 如果对象的equals方法被重写，那么对象的hashCode也尽量重写，并且产生hashCode使用的对象，一定要和equals方法中使用的一致，否则就会违反上面提到的第2点；
4. 两个对象的hashCode相同，并不一定表示两个对象就相同，也就是不一定适用于equals(java.lang.Object) 方法，只能够说明这两个对象在散列存储结构中，如Hashtable，他们“存放在同一个篮子里”。

归纳一下就是hashCode是用于查找使用的，而equals是用于比较两个对象的是否相等的:

    1.hashcode是用来查找的，如果你学过数据结构就应该知道，在查找和排序这一章有  
    例如内存中有这样的位置  
    0  1  2  3  4  5  6  7    
    而我有个类，这个类有个字段叫ID,我要把这个类存放在以上8个位置之一，如果不用hashcode而任意存放，那么当查找时就需要到这八个位置里挨个去找，或者用二分法一类的算法。  
    但如果用hashcode那就会使效率提高很多。  
    我们这个类中有个字段叫ID,那么我们就定义我们的hashcode为ID％8，然后把我们的类存放在取得得余数那个位置。比如我们的ID为9，9除8的余数为1，那么我们就把该类存在1这个位置，如果ID是13，求得的余数是5，那么我们就把该类放在5这个位置。这样，以后在查找该类时就可以通过ID除 8求余数直接找到存放的位置了。  
      
    2.但是如果两个类有相同的hashcode怎么办那（我们假设上面的类的ID不是唯一的），例如9除以8和17除以8的余数都是1，那么这是不是合法的，回答是：可以这样。那么如何判断呢？在这个时候就需要定义 equals了。  
    也就是说，我们先通过 hashcode来判断两个类是否存放某个桶里，但这个桶里可能有很多类，那么我们就需要再通过 equals 来在这个桶里找到我们要的类。  
    那么。重写了equals()，为什么还要重写hashCode()呢？  
    想想，你要在一个桶里找东西，你必须先要找到这个桶啊，你不通过重写hashcode()来找到桶，光重写equals()有什么用啊  


## 七、  ArrayList、LinkedList、Vector的区别

**Verctor基本情况介绍**：

>* Vector 是矢量队列，它是JDK1.0版本添加的类。继承于AbstractList，实现了List, RandomAccess, Cloneable这些接口。
* Vector 继承了AbstractList，实现了List；所以，它是一个队列，支持相关的添加、删除、修改、遍历等功能。
* Vector 实现了RandmoAccess接口，即提供了随机访问功能。RandmoAccess是java中用来被List实现，为List提供快速访问功能的。在Vector中，我们即可以通过元素的序号快速获取元素对象；这就是快速随机访问。
* Vector 实现了Cloneable接口，即实现clone()函数。它能被克隆。
和ArrayList不同，Vector中的操作是线程安全的。


**ArrayList,LinkedList,Vector这三个类都实现了java.util.List接口，但它们有各自不同的特性，主要如下：**

>* 一、同步性
ArrayList,LinkedList是不同步的，而Vector是的。所以如果不要求线程安全的话，可以使用ArrayList或LinkedList，可以节省为同步而耗费开销。但在多线程的情况下，有时候就不得不使用Vector了。当然，也可以通过一些办法包装ArrayList,LinkedList，使他们也达到同步，但效率可能会有所降低。
* 二、数据增长
从内部实现机制来讲ArrayList和Vector都是使用Objec的数组形式来存储的。当你向这两种类型中增加元素的时候，如果元素的数目超出了内部数组目前的长度它们都需要扩展内部数组的长度，Vector缺省情况下自动增长原来一倍的数组长度，ArrayList是原来的50%,所以最后你获得的这个集合所占的空间总是比你实际需要的要大。所以如果你要在集合中保存大量的数据那么使用Vector有一些优势，因为你可以通过设置集合的初始化大小来避免不必要的资源开销。
* 三、检索、插入、删除对象的效率
ArrayList和Vector中，从指定的位置（用index）检索一个对象，或在集合的末尾插入、删除一个对象的时间是一样的，可表示为O(1)。但是，如果在集合的其他位置增加或移除元素那么花费的时间会呈线形增长：O(n-i)，其中n代表集合中元素的个数，i代表元素增加或移除元素的索引位置。为什么会这样呢？以为在进行上述操作的时候集合中第i和第i个元素之后的所有元素都要执行(n-i)个对象的位移操作。
LinkedList中，在插入、删除集合中任何位置的元素所花费的时间都是一样的—O(1)，但它在索引一个元素的时候比较慢，为O(i),其中i是索引的位置。
所以，如果只是查找特定位置的元素或只在集合的末端增加、移除元素，那么使用Vector或ArrayList都可以。如果是对其它指定位置的插入、删除操作，最好选择LinkedList

## 八、 String、StringBuffer与StringBuilder的区别
String 字符串常量
StringBuffer 字符串变量（线程安全）
StringBuilder 字符串变量（非线程安全）

1. **String**
>String：字符串常量，字符串长度不可变。Java中String是immutable（不可变）的。

2. **StringBuffer**
>StringBuffer：字符串变量（Synchronized，即线程安全）。如果要频繁对字符串内容进行修改，出于效率考虑最好使用StringBuffer，如果想转成String类型，可以调用StringBuffer的toString()方法。
Java.lang.StringBuffer线程安全的可变字符序列。在任意时间点上它都包含某种特定的字符序列，但通过某些方法调用可以改变该序列的长度和内容。可将字符串缓冲区安全地用于多个线程。
StringBuffer 上的主要操作是 append 和 insert 方法，可重载这些方法，以接受任意类型的数据。每个方法都能有效地将给定的数据转换成字符串，然后将该字符串的字符追加或插入到字符串缓冲区中。append 方法始终将这些字符添加到缓冲区的末端；而 insert 方法则在指定的点添加字符。例如，如果 z 引用一个当前内容是“start”的字符串缓冲区对象，则此方法调用 z.append("le") 会使字符串缓冲区包含“startle”，而 z.insert(4, "le") 将更改字符串缓冲区，使之包含“starlet”。

3. **StringBuilder**
>字符串变量（非线程安全）。在内部，StringBuilder对象被当作是一个包含字符序列的变长数组。
java.lang.StringBuilder是一个可变的字符序列，是JDK5.0新增的。此类提供一个与 StringBuffer 兼容的 API，但不保证同步。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候（这种情况很普遍）。
在大部分情况下，StringBuilder > StringBuffer。这主要是由于前者不需要考虑线程安全。

区别：
>String 类型和StringBuffer的主要性能区别：String是不可变的对象, 因此在每次对String 类型进行改变的时候，都会生成一个新的 String 对象，然后将指针指向新的 String 对象，所以经常改变内容的字符串最好不要用 String ，因为每次生成对象都会对系统性能产生影响，特别当内存中无引用对象多了以后， JVM 的 GC 就会开始工作，性能就会降低。
使用 StringBuffer 类时，每次都会对 StringBuffer 对象本身进行操作，而不是生成新的对象并改变对象引用。所以多数情况下推荐使用 StringBuffer ，特别是字符串对象经常改变的情况下。

 使用策略:
 >1. 基本原则：如果要操作少量的数据，用String ；单线程操作大量数据，用StringBuilder ；多线程操作大量数据，用StringBuffer。
2. 不要使用String类的"+"来进行频繁的拼接，因为那样的性能极差的，应该使用StringBuffer或StringBuilder类，这在Java的优化上是一条比较重要的原则。
3. 为了获得更好的性能，在构造 StirngBuffer 或 StirngBuilder 时应尽可能指定它们的容量。当然，如果你操作的字符串长度（length）不超过 16 个字符就不用了，当不指定容量（capacity）时默认构造一个容量为16的对象。不指定容量会显著降低性能。
4. StringBuilder一般使用在方法内部来完成类似"+"功能，因为是线程不安全的，所以用完以后可以丢弃。StringBuffer主要用在全局变量中。
5. 相同情况下使用 StirngBuilder 相比使用 StringBuffer 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。而在现实的模块化编程中，负责某一模块的程序员不一定能清晰地判断该模块是否会放入多线程的环境中运行，因此：除非确定系统的瓶颈是在 StringBuffer 上，并且确定你的模块不会运行在多线程模式下，才可以采用StringBuilder；否则还是用StringBuffer。

## 九、 Map、Set、List、Queue、Stack的特点与用法
集合类基本概念：
>集合类主要负责保存、盛装其他数据，因此集合类也被称为容器类。所以的集合类都位于java.util包下，后来为了处理多线程环境下的并发安全问题，java5还在java.util.concurrent包下提供了一些多线程支持的集合类。

容器类类库(作用是保存对象)：
>1. Collection
一组"对立"的元素，通常这些元素都服从某种规则
 　　1.1 List必须保持元素特定的顺序
 　　1.2 Set不能有重复元素
 　　1.3 Queue保持一个队列(先进先出)的顺序
2. Map
一组成对的"键值对"对象
3. 注：Collection和Map的区别:
* Collection 每个位置只能保存一个元素(对象)
*  Map保存的是"键值对"，就像一个小型数据库。我们可以通过"键"找到该键对应的"值"

 **Java集合类架构层次关系**
 [原文地址](http://www.cnblogs.com/LittleHann/p/3690187.html)
 >1. Interface Iterable
迭代器接口，这是Collection类的父接口。实现这个Iterable接口的对象允许使用foreach进行遍历，也就是说，所有的Collection集合对象都具有"foreach可遍历性"。这个Iterable接口只
有一个方法: iterator()。它返回一个代表当前集合对象的泛型<T>迭代器，用于之后的遍历操作
1.1 Collection
Collection是最基本的集合接口，一个Collection代表一组Object的集合，这些Object被称作Collection的元素。Collection是一个接口，用以提供规范定义，不能被实例化使用
    1) Set
    Set集合类似于一个罐子，"丢进"Set集合里的多个对象之间没有明显的顺序。Set继承自Collection接口，不能包含有重复元素(记住，这是整个Set类层次的共有属性)。
    Set判断两个对象相同不是使用"=="运算符，而是根据equals方法。也就是说，我们在加入一个新元素的时候，如果这个新元素对象和Set中已有对象进行注意equals比较都返回false，　　
 　 则Set就会接受这个新元素对象，否则拒绝。
    因为Set的这个制约，在使用Set集合的时候，应该注意两点：1) 为Set集合里的元素的实现类实现一个有效的equals(Object)方法、2) 对Set的构造函数，传入的Collection参数不能包
　　含重复的元素
        1.1) HashSet
        HashSet是Set接口的典型实现，HashSet使用HASH算法来存储集合中的元素，因此具有良好的存取和查找性能。当向HashSet集合中存入一个元素时，HashSet会调用该对象的
　　　　 hashCode()方法来得到该对象的hashCode值，然后根据该HashCode值决定该对象在HashSet中的存储位置。
        值得主要的是，HashSet集合判断两个元素相等的标准是两个对象通过equals()方法比较相等，并且两个对象的hashCode()方法的返回值相等
            1.1.1) LinkedHashSet
            LinkedHashSet集合也是根据元素的hashCode值来决定元素的存储位置，但和HashSet不同的是，它同时使用链表维护元素的次序，这样使得元素看起来是以插入的顺序保存的。
　　　　　　　当遍历LinkedHashSet集合里的元素时，LinkedHashSet将会按元素的添加顺序来访问集合里的元素。
            LinkedHashSet需要维护元素的插入顺序，因此性能略低于HashSet的性能，但在迭代访问Set里的全部元素时(遍历)将有很好的性能(链表很适合进行遍历)
        1.2) SortedSet    
        此接口主要用于排序操作，即实现此接口的子类都属于排序的子类
            1.2.1) TreeSet
            TreeSet是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态
        1.3) EnumSet
        EnumSet是一个专门为枚举类设计的集合类，EnumSet中所有元素都必须是指定枚举类型的枚举值，该枚举类型在创建EnumSet时显式、或隐式地指定。EnumSet的集合元素也是有序的，
　　　　 它们以枚举值在Enum类内的定义顺序来决定集合元素的顺序
    2) List
    List集合代表一个元素有序、可重复的集合，集合中每个元素都有其对应的顺序索引。List集合允许加入重复元素，因为它可以通过索引来访问指定位置的集合元素。List集合默认按元素
　　 的添加顺序设置元素的索引
        2.1) ArrayList
        ArrayList是基于数组实现的List类，它封装了一个动态的增长的、允许再分配的Object[]数组。
        2.2) Vector
        Vector和ArrayList在用法上几乎完全相同，但由于Vector是一个古老的集合，所以Vector提供了一些方法名很长的方法，但随着JDK1.2以后，java提供了系统的集合框架，就将
　　　　 Vector改为实现List接口，统一归入集合框架体系中
            2.2.1) Stack
            Stack是Vector提供的一个子类，用于模拟"栈"这种数据结构(LIFO后进先出)
        2.3) LinkedList
        implements List<E>, Deque<E>。实现List接口，能对它进行队列操作，即可以根据索引来随机访问集合中的元素。同时它还实现Deque接口，即能将LinkedList当作双端队列
　　　　 使用。自然也可以被当作"栈来使用"
    3) Queue
    Queue用于模拟"队列"这种数据结构(先进先出 FIFO)。队列的头部保存着队列中存放时间最长的元素，队列的尾部保存着队列中存放时间最短的元素。新元素插入(offer)到队列的尾部，
　　 访问元素(poll)操作会返回队列头部的元素，队列不允许随机访问队列中的元素。结合生活中常见的排队就会很好理解这个概念
        3.1) PriorityQueue
        PriorityQueue并不是一个比较标准的队列实现，PriorityQueue保存队列元素的顺序并不是按照加入队列的顺序，而是按照队列元素的大小进行重新排序，这点从它的类名也可以
　　　　 看出来
        3.2) Deque
        Deque接口代表一个"双端队列"，双端队列可以同时从两端来添加、删除元素，因此Deque的实现类既可以当成队列使用、也可以当成栈使用
            3.2.1) ArrayDeque
            是一个基于数组的双端队列，和ArrayList类似，它们的底层都采用一个动态的、可重分配的Object[]数组来存储集合元素，当集合元素超出该数组的容量时，系统会在底层重
　　　　　　　新分配一个Object[]数组来存储集合元素
            3.2.2) LinkedList
1.2 Map
Map用于保存具有"映射关系"的数据，因此Map集合里保存着两组值，一组值用于保存Map里的key，另外一组值用于保存Map里的value。key和value都可以是任何引用类型的数据。Map的key不允
许重复，即同一个Map对象的任何两个key通过equals方法比较结果总是返回false。
关于Map，我们要从代码复用的角度去理解，java是先实现了Map，然后通过包装了一个所有value都为null的Map就实现了Set集合
Map的这些实现类和子接口中key集的存储形式和Set集合完全相同(即key不能重复)
Map的这些实现类和子接口中value集的存储形式和List非常类似(即value可以重复、根据索引来查找)
    1) HashMap
    和HashSet集合不能保证元素的顺序一样，HashMap也不能保证key-value对的顺序。并且类似于HashSet判断两个key是否相等的标准也是: 两个key通过equals()方法比较返回true、
　　 同时两个key的hashCode值也必须相等
        1.1) LinkedHashMap
        LinkedHashMap也使用双向链表来维护key-value对的次序，该链表负责维护Map的迭代顺序，与key-value对的插入顺序一致(注意和TreeMap对所有的key-value进行排序进行区
分)
    2) Hashtable
    是一个古老的Map实现类
        2.1) Properties 
        Properties对象在处理属性文件时特别方便(windows平台上的.ini文件)，Properties类可以把Map对象和属性文件关联起来，从而可以把Map对象中的key-value对写入到属性文
　　　　　件中，也可以把属性文件中的"属性名-属性值"加载到Map对象中
    3) SortedMap
    正如Set接口派生出SortedSet子接口，SortedSet接口有一个TreeSet实现类一样，Map接口也派生出一个SortedMap子接口，SortedMap接口也有一个TreeMap实现类
        3.1) TreeMap
        TreeMap就是一个红黑树数据结构，每个key-value对即作为红黑树的一个节点。TreeMap存储key-value对(节点)时，需要根据key对节点进行排序。TreeMap可以保证所有的
　　　　 key-value对处于有序状态。同样，TreeMap也有两种排序方式: 自然排序、定制排序
    4) WeakHashMap
    WeakHashMap与HashMap的用法基本相似。区别在于，HashMap的key保留了对实际对象的"强引用"，这意味着只要该HashMap对象不被销毁，该HashMap所引用的对象就不会被垃圾回收。
　　但WeakHashMap的key只保留了对实际对象的弱引用，这意味着如果WeakHashMap对象的key所引用的对象没有被其他强引用变量所引用，则这些key所引用的对象可能被垃圾回收，当垃
　　圾回收了该key所对应的实际对象之后，WeakHashMap也可能自动删除这些key所对应的key-value对
    5) IdentityHashMap
    IdentityHashMap的实现机制与HashMap基本相似，在IdentityHashMap中，当且仅当两个key严格相等(key1 == key2)时，IdentityHashMap才认为两个key相等
    6) EnumMap
    EnumMap是一个与枚举类一起使用的Map实现，EnumMap中的所有key都必须是单个枚举类的枚举值。创建EnumMap时必须显式或隐式指定它对应的枚举类。EnumMap根据key的自然顺序
　　(即枚举值在枚举类中的定义顺序)

## 十、 HashMap和HashTable、ConcurrenHashMap的区别
|   |   |   |  |   |   |   |   | |
| ------| 
| HashMap    | 线程不安全 |   允许有null的键和值     | 效率高一点 |方法不是Synchronize的要提供外同步 | 有containsvalue和containsKey方法 | HashMap 是Java1.2 引进的Map interface 的一个实现 |HashMap是Hashtable的轻量级实现 |
| Hashtable      |   线程安全   |   不允许有null的键和值   | 效率稍低|  方法是是Synchronize的 |  有contains方法方法| Hashtable 继承于Dictionary 类 | Hashtable 比HashMap 要旧|

更好的选择：ConcurrentHashMap：
>java5中新增了ConcurrentMap接口和它的一个实现类ConcurrentHashMap。
ConcurrentHashMap提供了和Hashtable以及SynchronizedMap中所不同的锁机制。

>Hashtable中采用的锁机制是一次锁住整个hash表，从而同一时刻只能由一个线程对其进行操作；

>而ConcurrentHashMap中则是一次锁住一个桶。
ConcurrentHashMap默认将hash表分为16个桶，诸如get,put,remove等常用操作只锁当前需要用到的桶。
这样，原来只能一个线程进入，现在却能同时有16个写线程执行，并发性能的提升是显而易见的。
 上面说到的16个线程指的是写线程，而读操作大部分时候都不需要用到锁。只有在size等操作时才需要锁住整个hash表。
 
 >在迭代方面，ConcurrentHashMap使用了一种不同的迭代方式。
在这种迭代方式中，当iterator被创建后集合再发生改变就不再是抛出ConcurrentModificationException，取而代之的是在改变时new新的数据从而不影响原有的数据 。iterator完成后再将头指针替换为新的数据 。这样iterator线程可以使用原来老的数据。而写线程也可以并发的完成改变。


hashmap原理：
[参考](http://yikun.github.io/2015/04/01/Java-HashMap%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%8F%8A%E5%AE%9E%E7%8E%B0/)

## 十一、 TreeMap、HashMap、LindedHashMap的区别
HashMap
>Hashmap 是一个最常用的Map,它根据键的HashCode 值存储数据,根据键可以直接获取它的值，具有很快的访问速度，遍历时，取得数据的顺序是完全随机的。HashMap最多只允许一条记录的键为Null;允许多条记录的值为 Null;HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap;可能会导致数据的不一致。如果需要同步，可以用 Collections的synchronizedMap方法使HashMap具有同步的能力，或者使用ConcurrentHashMap。

LinkedHashMap:
>LinkedHashMap保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的.也可以在构造时用带参数，按照应用次数排序。在遍历的时候会比HashMap慢，不过有种情况例外，当HashMap容量很大，实际数据较少时，遍历起来可能会比LinkedHashMap慢，因为LinkedHashMap的遍历速度只和实际数据有关，和容量无关，而HashMap的遍历速度和他的容量有关。(继承自HashMap)

TreeMap:
>TreeMap实现SortMap接口，能够把它保存的记录根据键排序,默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。

一般情况下，我们用的最多的是HashMap,HashMap里面存入的键值对在取出的时候是随机的,它根据键的HashCode值存储数据,根据键可以直接获取它的值，具有很快的访问速度。在Map 中插入、删除和定位元素，HashMap 是最好的选择。
TreeMap取出来的是排序后的键值对。但如果您要按自然顺序或自定义顺序遍历键，那么TreeMap会更好。
LinkedHashMap 是HashMap的一个子类，如果需要输出的顺序和输入的相同,那么用LinkedHashMap可以实现,它还可以按读取顺序来排列，像连接池中可以应用。

## 十二、 Collection包结构，与Collections的区别




## 十三、 Excption与Error
1. Throwable 
>Throwable是 Java 语言中所有错误或异常的超类。 
Throwable包含两个子类: Error 和 Exception 。它们通常用于指示发生了异常情况。 
Throwable包含了其线程创建时线程执行堆栈的快照，它提供了printStackTrace()等接口用于获取堆栈跟踪数据等信息。

2. Exception 
>Exception及其子类是Throwable的一种形式，它指出了合理的应用程序想要捕获的条件。

3. RuntimeException 
>RuntimeException是那些可能在Java虚拟机正常运行期间抛出的异常的超类。 
编译器不会检查RuntimeException异常。 例如，除数为零时，抛出ArithmeticException异常。RuntimeException是ArithmeticException的超类。当代码发生除数为零的情况时，倘若既"没有通过throws声明抛出ArithmeticException异常"，也"没有通过try...catch...处理该异常"，也能通过编译。这就是我们所说的"编译器不会检查RuntimeException异常"！ 
如果代码会产生RuntimeException异常，则需要通过修改代码进行避免。 例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！

4. Error 
>和Exception一样， Error也是Throwable的子类。 它用于指示合理的应用程序不应该试图捕获的严重问题，大多数这样的错误都是异常条件。 
和RuntimeException一样， 编译器也不会检查Error。

Java将可抛出(Throwable)的结构分为三种类型： 被检查的异常(Checked Exception)，运行时异常(RuntimeException)和错误(Error)。

1. 运行时异常 
>定义 : RuntimeException及其子类都被称为运行时异常。 
特点 : Java编译器不会检查它。 也就是说，当程序中可能出现这类异常时，倘若既"没有通过throws声明抛出它"，也"没有用try-catch语句捕获它"，还是会编译通过。例如，除数为零时产生的ArithmeticException异常，数组越界时产生的IndexOutOfBoundsException异常，fail-fail机制产生的ConcurrentModificationException异常等，都属于运行时异常。 
虽然Java编译器不会检查运行时异常，但是我们也可以通过throws进行声明抛出，也可以通过try-catch对它进行捕获处理。 
如果产生运行时异常，则需要通过修改代码来进行避免。 例如，若会发生除数为零的情况，则需要通过代码避免该情况的发生！

2. 被检查的异常 
>定义 :  Exception类本身，以及Exception的子类中除了"运行时异常"之外的其它子类都属于被检查异常。 
特点 : Java编译器会检查它。 此类异常，要么通过throws进行声明抛出，要么通过try-catch进行捕获处理，否则不能通过编译。例如，CloneNotSupportedException就属于被检查异常。当通过clone()接口去克隆一个对象，而该对象对应的类没有实现Cloneable接口，就会抛出CloneNotSupportedException异常。 
被检查异常通常都是可以恢复的。

3. 错误 
>定义 : Error类及其子类。 
特点 : 和运行时异常一样，编译器也不会对错误进行检查。 
当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误。程序本身无法修复这些错误的。例如，VirtualMachineError就属于错误。 
按照Java惯例，我们是不应该是实现任何新的Error子类的！

**对于可以恢复的条件使用被检查异常，对于程序错误使用运行时异常。**

## 十四、  Java面向对象的三个特征与含义

**封装**
>所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。封装是面向对象的特征之一，是对象和类概念的主要特性。 简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。

**继承**
>所谓继承是指可以让某个类型的对象获得另一个类型的对象的属性的方法。它支持按级分类的概念。继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。 通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。要实现继承，可以通过“继承”（Inheritance）和“组合”（Composition）来实现。继承概念的实现方式有二类：实现继承与接口继承。实现继承是指直接使用基类的属性和方法而无需额外编码的能力；接口继承是指仅使用属性和方法的名称、但是子类必须提供实现的能力；

 
**多态**
>所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。

 

封装可以隐藏实现细节，使得代码模块化；继承可以扩展已存在的代码模块（类）；它们的目的都是为了——代码重用。而多态则是为了实现另一个目的——接口重用！多态的作用，就是为了类在继承和派生的时候，保证使用“家谱”中任一类的实例的某一属性时的正确调用。

## 十五、Override和Overload的含义的区别

java中的继承，方法覆盖（重写）override与方法的重载overload的区别 

方法的重写(Overriding)和重载(Overloading)是Java多态性的不同表现。   
>重写(Overriding)是父类与子类之间多态性的一种表现，而重载(Overloading)是一个类中多态性的一种表现。如果在子类中定义某方法与其父类有相同的名称和参数，我们说该方法被重写 (Overriding) 。子类的对象使用这个方法时，将调用子类中的定义，对它而言，父类中的定义如同被"屏蔽"了。如果在一个类中定义了多个同名的方法，它们或有不同的参数个数或有不同的参数类型或有不同的参数次序，则称为方法的重载(Overloading)。不能通过访问权限、返回类型、抛出的异常进行重载。 

1.  Override 特点   
>1、覆盖的方法的标志必须要和被覆盖的方法的标志完全匹配，才能达到覆盖的效果；   
2、覆盖的方法的返回值必须和被覆盖的方法的返回一致；   
3、覆盖的方法所抛出的异常必须和被覆盖方法的所抛出的异常一致，或者是其子类； 
4、方法被定义为final不能被重写。  
5、对于继承来说，如果某一方法在父类中是访问权限是private，那么就不能在子类对其进行重写覆盖，如果定义的话，也只是定义了一个新方法，而不会达到重写覆盖的效果。（通常存在于父类和子类之间。） 


2. Overload 特点   
>1、在使用重载时只能通过不同的参数样式。例如，不同的参数类型，不同的参数个数，不同的参数顺序（当然，同一方法内的几个参数类型必须不一样，例如可以是fun(int, float)， 但是不能为fun(int, int)）；   
2、不能通过访问权限、返回类型、抛出的异常进行重载；   
3、方法的异常类型和数目不会对重载造成影响；   
4、重载事件通常发生在同一个类中，不同方法之间的现象。 
5、存在于同一类中，但是只有虚方法和抽象方法才能被覆写。 

其具体实现机制： 

overload是重载，重载是一种参数多态机制，即代码通过参数的类型或个数不同而实现的多态机制。 是一种静态的绑定机制（在编译时已经知道具体执行的是哪个代码段）。   
    
override是覆盖。覆盖是一种动态绑定的多态机制。即在父类和子类中同名元素（如成员函数）有不同的实现代码。执行的是哪个代码是根据运行时实际情况而定的。

## 十六、 Interface与abstract类的区别

含有abstract修饰符的class即为抽象类，abstract类不能创建的实例对象。含有abstract方法的类必须定义为abstract class，abstractclass类中的方法不必是抽象的。abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果的子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。 

接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。 

下面比较一下两者的语法区别： 
>1.抽象类可以有构造方法，接口中不能有构造方法。 
2.抽象类中可以有普通成员变量，接口中没有普通成员变量 
3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。 
4. 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然 
eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。 
5. 抽象类中可以包含静态方法，接口中不能包含静态方法 
6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。 
7. 一个类可以实现多个接口，但只能继承一个抽象类。 

下面接着再说说两者在应用上的区别： 
接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用。


参数 |	抽象类|	接口
---|---|---
默认的方法实现|	它可以有默认的方法实现|接口完全是抽象的。它根本不存在方法的实现
实现|	子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现。|子类使用关键字implements来实现接口。它需要提供接口中所有声明的方法的实现
构造器	|抽象类可以有构造器|	接口不能有构造器
与正常Java类的区别|	除了你不能实例化抽象类之外，它和普通Java类没有任何区别|接口是完全不同的类型
访问修饰符	|抽象方法可以有public、protected和default这些修饰符	|接口方法默认修饰符是public。你不可以使用其它修饰符。
main方法|	抽象方法可以有main方法并且我们可以运行它	|接口没有main方法，因此我们不能运行它。
多继承|	抽象方法可以继承一个类和实现多个接口	|接口只可以继承一个或多个其它接口
速度|	它比接口速度要快	|接口是稍微有点慢的，因为它需要时间去寻找在类中实现的方法。
添加新方法|	如果你往抽象类中添加新的方法，你可以给它提供默认的实现。因此你不需要改变你现在的代码。|如果你往接口中添加方法，那么你必须改变实现该接口的类。

**什么时候使用抽象类和接口**

* 如果你拥有一些方法并且想让它们中的一些有默认实现，那么使用抽象类吧。
* 如果你想实现多重继承，那么你必须使用接口。由于Java不支持多继承，子类不能够继承多个类，但可以实现多个接口。因此你就可以使用接口来解决它。
* 如果基本功能在不断改变，那么就需要使用抽象类。如果不断改变基本功能并且使用接口，那么就需要改变所有实现了该接口的类。



## 十七、 Static class 与non static class的区别

static class | non static class
--|--
用static修饰的是内部类，此时这个内部类变为静态内部类；对测试有用； | 
内部静态类不需要有指向外部类的引用； | 非静态内部类需要持有对外部类的引用； 
静态类只能访问外部类的静态成员，不能访问外部类的非静态成员；| 非静态内部类能够访问外部类的静态和非静态成员；
 .  |  一个非静态内部类不能脱离外部类实体被创建；<br>一个非静态内部类可以访问外部类的数据和方法；

## 十八、  java多态的实现原理
1、多态的定义：
>指允许不同类的对象，对同一消息作出响应；
即同一消息可以根据发送对象的不同采用多种不同的行为方式；

2、多态的实现技术：
>动态绑定；
指在执行期间判断所引用对象的实际类型，根据其实际的类型调用其相应的方法；

3、多态的作用：消除类型之间的耦合关系；
　比如：按下F1键这个动作，在word中弹出word帮助；在windows下弹出的是Windows帮助文档；
　
4、多态存在的三个条件：有继承；有重写；父类引用指向子类对象；

5、多态实现的2中方式：覆盖和重载；

## 十九、  实现多线程三种方法：Thread与Runable、Callable（有返回值）

Java 中实现多线程有两种方法：继承 Thread 类、实现 Runnable 接口，在程序开发中只要是多线程，肯定永远以实现 Runnable 接口为主，因为实现 Runnable 接口相比继承 Thread 类有如下优势：

    * 可以避免由于 Java 的单继承特性而带来的局限；
    * 增强程序的健壮性，代码能够被多个线程共享，代码与数据是独立的；
    * 适合多个相同程序代码的线程区处理同一资源的情况。
    
继承Thread类要实现Run方法，然后调用start方法就可以让创建的线程进行运行。（具体什么时候执行需要取决于操作系统）
实现Runable接口要先重写Run方法，然后需要构造一个Thread对象，最后调用Thread对象的start方法开始运行。（具体执行时间取决于操作系统）

## 二十、  线程同步的方法：sychronized、lock、reentrantLock

[我的博客-线程](http://www.cnblogs.com/snail-lb/p/5468738.html)

**线程同步的几种方法：**

1. 使用synchronized 关键字。
* 在方法上使用synchronized 关键字
* 利用synchronized 构建同步语句块
2. 利用加锁来进行同步
```
class X {
   private static Lock lock = new ReentrantLock();     //创建锁
   // ...
   public void m() { 
     lock.lock();  // 加锁
     try {
       // ... method body
     } finally {
       lock.unlock()//解锁
     }
   }
 }
```
3. 利用信号量模拟加锁，保证同步
```
        //创建只有一个许可的信号量，表示同时只有一个线程能访问deposit()方法
        private static Semaphore semaphore = new Semaphore(1);

        public  void deposit(int amount) {
            try{
                semaphore.acquire();    //捕获许可
                //..........
                }catch (InterruptedException ex){
                }finally{
                semaphore.release();    //释放许可
                }
            }
        }
```

**ReentrantLock相对于synchronized多了三个高级功能：** 　　 　
>1. 等待可中断:　
在持有锁的线程长时间不释放锁的时候,等待的线程可以选择放弃等待. 　　
tryLock(long timeout, TimeUnit unit)
<br>
2. 公平锁:
按照申请锁的顺序来一次获得锁称为公平锁.synchronized的是非公平锁,ReentrantLock可以通过构造函数实现公平锁.
new RenentrantLock(boolean fair)

    公平锁和非公平锁。这2种机制的意思从字面上也能了解个大概：即对于多线程来说，公平锁会依赖线程进来的顺序，后进来的线程后获得锁。而非公平锁的意思就是后进来的锁也可以和前边等待锁的线程同时竞争锁资源。对于效率来讲，当然是非公平锁效率更高，因为公平锁还要判断是不是线程队列的第一个才会让线程获得锁。 　　 　　

>3.绑定多个Condition:
通过多次newCondition可以获得多个Condition对象,可以简单的实现比较复杂的线程同步的功能.通过await(),signal();

**synchronized和lock的用法与区别**
> * synchronized是托管给JVM执行的，而lock是java写的控制锁的代码。
* synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低。　 　 　Lock用的是乐观锁方式。每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。
    
    ReentrantLock必须在finally中释放锁，否则后果很严重，编码角度来说使用synchronized更加简单，不容易遗漏或者出错。

> * ReentrantLock提供了可轮询的锁请求，他可以尝试的去取得锁，如果取得成功则继续处理，取得不成功，可以等下次运行的时候处理，所以不容易产生死锁，而synchronized则一旦进入锁请求要么成功，要么一直阻塞，所以更容易产生死锁。
<br>
synchronized的话，锁的范围是整个方法或synchronized块部分；而Lock因为是方法调用，可以跨方法，灵活性更大

**一般情况下都是用synchronized原语实现同步，除非下列情况使用ReentrantLock** 
>1. 某个线程在等待一个锁的控制权的这段时间需要中断 
2.  需要分开处理一些wait-notify，ReentrantLock里面的Condition应用，能够控制notify哪个线程 
3. 具有公平锁功能，每个到来的线程都将排队等候

**Lock的几种实现类**
>1. ReentrantLock
2. ReentrantReadWriteLock.ReadLock
3. ReentrantReadWriteLock.WriteLock


##  二十一、  锁的等级：方法锁、对象锁、类锁

>synchronized 
在修饰代码块的时候需要一个reference对象作为锁的对象. 
在修饰方法的时候默认是当前对象作为锁的对象. 
在修饰类时候默认是当前类的Class对象作为锁的对象. 

**方法锁（synchronized修饰方法时）**

>通过在方法声明中加入 synchronized关键字来声明 synchronized 方法。
<br>
synchronized 方法控制对类成员变量的访问： 
每个类实例对应一把锁，每个 synchronized 方法都必须获得调用该方法的类实例的锁方能执行，否则所属线程阻塞，方法一旦执行，就独占该锁，直到从该方法返回时才将锁释放，此后被阻塞的线程方能获得该锁，重新进入可执行状态。这种机制确保了同一时刻对于每一个类实例，其所有声明为 synchronized 的成员函数中至多只有一个处于可执行状态，从而有效避免了类成员变量的访问冲突。

**对象锁（synchronized修饰方法或代码块）**

>当一个对象中有synchronized method或synchronized block的时候调用此对象的同步方法或进入其同步区域时，就必须先获得对象锁。如果此对象的对象锁已被其他调用者占用，则需要等待此锁被释放。（方法锁也是对象锁）
<br>
java的所有对象都含有1个互斥锁，这个锁由JVM自动获取和释放。线程进入synchronized方法的时候获取该对象的锁，当然如果已经有线程获取了这个对象的锁，那么当前线程会等待；synchronized方法正常返回或者抛异常而终止，JVM会自动释放对象锁。这里也体现了用synchronized来加锁的1个好处，方法抛异常的时候，锁仍然可以由JVM来自动释放。　

对象锁的两种形式：
```
public class Test
{
    // 对象锁：形式1(方法锁)
    public synchronized void Method1()
    {
        System.out.println("我是对象锁也是方法锁");
        try
        {
            Thread.sleep(500);
        } catch (InterruptedException e)
        {
            e.printStackTrace();
        }

    }
```
```
    // 对象锁：形式2（代码块形式）
    public void Method2()
    {
        synchronized (this)
        {
            System.out.println("我是对象锁");
            try
            {
                Thread.sleep(500);
            } catch (InterruptedException e)
            {
                e.printStackTrace();
            }
        }

    }
 ｝
```

**类锁(synchronized 修饰静态的方法或代码块)**

>由于一个class不论被实例化多少次，其中的静态方法和静态变量在内存中都只有一份。所以，一旦一个静态的方法被申明为synchronized。此类所有的实例化对象在调用此方法，共用同一把锁，我们称之为类锁
<br>
对象锁是用来控制实例方法之间的同步，类锁是用来控制静态方法（或静态变量互斥体）之间的同步。　 
 
类锁只是一个概念上的东西，并不是真实存在的，它只是用来帮助我们理解锁定实例方法和静态方法的区别的。　 
java类可能会有很多个对象，但是只有1个Class对象，也就是说类的不同实例之间共享该类的Class对象。Class对象其实也仅仅是1个java对象，只不过有点特殊而已。由于每个java对象都有1个互斥锁，而类的静态方法是需要Class对象。所以所谓的类锁，不过是Class对象的锁而已。获取类的Class对象有好几种，最简单的就是［类名.class］的方式。

## 二十二、 生产者消费者模式
[我的博客-线程](http://www.cnblogs.com/snail-lb/p/5468738.html)
```
package thread;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class ConsumerProducer {
	private static final Product product = new Product();
	public static void main(String[] args) {
		ExecutorService executor = Executors.newFixedThreadPool(2);
		executor.execute(new Consumer());
		executor.execute(new Producer());
		executor.shutdown();
	}
	
	private static class Consumer implements Runnable{
		@Override
		public void run() {
			while(true){
				try {
					product.add((int)(2+Math.random()*14));
					TimeUnit.MILLISECONDS.sleep((int)(Math.random() * 1000));
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
	}
	
	private static class Producer implements Runnable{
		@Override
		public void run() {
			while(true){
				try {
					product.reduct((int)(2+Math.random()*14));
					TimeUnit.MILLISECONDS.sleep((int)(Math.random() * 1000));
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
		}
	}
}


class Product{
	private static final int PRODUCT_MAX_SIZE = 20;
	private Integer account = 0;
	private static Lock lock = new ReentrantLock();
	private static Condition reductLock = lock.newCondition();
	private static Condition addLock = lock.newCondition();
	
	public void add(int num){
		lock.lock();
		try {
			while( account > PRODUCT_MAX_SIZE){
				//加锁等待取款
				addLock.await();
				if(account > PRODUCT_MAX_SIZE){
					System.out.println("准备存入" + num + "元，但账户总金额超过限制，等待取款");
				}
			}
			account += num;
			System.out.println("存入" + num + "元\t账户余额" + account);
			reductLock.signal();
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			lock.unlock();
		}
	}
	
	public void reduct(int num){
		lock.lock();
		try {
			while(num > account){
				//加锁等待存款
				reductLock.await();
				if(num > account){
					System.out.println("准备取出"+num+"元，但余额不足、等待存款");
				}
			}
			account -= num;
			System.out.println("取出" + num + "元\t账户余额" + account);
			addLock.signal();
		} catch (Exception e) {
			e.printStackTrace();
		}finally{
			lock.unlock();
		}
	}
}
```

##二十三、  ThreadLocal的设计理念与作用

**ThreadLocal是什么**
>ThreadLocal是什么呢？其实ThreadLocal并非是一个线程的本地实现版本，它并不是一个Thread，而是thread local variable（线程局部变量）。也许把它命名为ThreadLocalVar更加合适。线程局部变量（ThreadLocal）其实的功用非常简单，**就是为每一个使用该变量的线程都提供一个变量值的副本，是每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲突。**从线程的角度看，就好像每一个线程都完全拥有该变量。线程局部变量并不是Java的新发明，在其它的一些语言编译器实现（如IBM XL FORTRAN）中，它在语言的层次提供了直接的支持。因为Java中没有提供在语言层次的直接支持，而是提供了一个ThreadLocal的类来提供支持，所以，在Java中编写线程局部变量的代码相对比较笨拙，这也许是线程局部变量没有在Java中得到很好的普及的一个原因吧。

 ThreadLocal是如何做到为每一个线程维护变量的副本的呢？其实实现的思路很简单，在ThreadLocal类中有一个Map，用于存储每一个线程的变量的副本。
 
 
 
 使用：
```
package thread;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

public class TestThreadLocal_2 {
	public static void main(String[] args) {
		ExecutorService executor  = Executors.newFixedThreadPool(6);
		for(int i = 0; i < 3; i++){
			executor.execute(new ThreadLocal_1());
		}
		for(int i = 0; i < 3; i++){
			executor.execute(new ThreadLocal_2());
		}
		executor.shutdown();
	}
}

class ThreadLocal_1 implements Runnable{
	String str = "string";
	@Override
	public void run() {
		System.out.println(str + ":  " + str.hashCode());
	}
	
}
class ThreadLocal_2 implements Runnable{
	ThreadLocal<String> myThreadString = new ThreadLocal<String>();
	@Override
	public void run() {
		myThreadString.set("myThreadString");
		System.out.println(myThreadString.get() + ":  " + myThreadString.hashCode());
		
	}
	
}
```
运行结果：
>string:  -891985903
string:  -891985903
string:  -891985903
myThreadString:  2013302890
myThreadString:  1457082849
myThreadString:  229996315


## 二十四、ThreadPool用法与优势

优点：
>（1）降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗；
（2）提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行；
（3）提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。

　　线程池可以应对突然大爆发量的访问，通过有限个固定线程为大量的操作服务，减少创建和销毁线程所需的时间。




Java通过Executors提供四种线程池，分别为：
>1.  newCachedThreadPool创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。
`ExecutorService cachedThreadPool = Executors.newCachedThreadPool();`
>2. newFixedThreadPool 创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。
`ExecutorService threadPool = Executors.newFixedThreadPool(4);`
>3. newScheduledThreadPool 创建一个定长线程池，支持定时及周期性任务执行。
` ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(4);`
>4. newSingleThreadExecutor 创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。
`ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();`

## 二十五、 wait()和sleep()的区别

**sleep**(保持了对象锁)
>sleep()使当前线程进入停滞状态（阻塞当前线程），让出CUP的使用、目的是不让当前线程独自霸占该进程所获的CPU资源，以留一定时间给其他线程执行的机会;
　　 sleep()是Thread类的Static(静态)的方法；因此他不能改变对象的机锁，所以当在一个Synchronized块中调用Sleep()方法是，线程虽然休眠了，但是对象的机锁并木有被释放，其他线程无法访问这个对象（即使睡着也持有对象锁）。
　　在sleep()休眠时间期满后，该线程不一定会立即执行，这是因为其它线程可能正在运行而且没有被调度为放弃执行，除非此线程具有更高的优先级。 

**wait**（释放了对象锁）
>wait()方法是Object类里的方法；当一个线程执行到wait()方法时，它就进入到一个和该对象相关的等待池中，同时失去（释放）了对象的机锁（暂时失去机锁，wait(long timeout)超时时间到后还需要返还对象锁）；其他线程可以访问；
　　wait()使用notify或者notifyAlll或者指定睡眠时间来唤醒当前等待池中的线程。
　　wiat()必须放在synchronized block中，否则会在program runtime时扔出”java.lang.IllegalMonitorStateException“异常。

## 二十六、for-each 与 for循环 效率对比
for-each内部是使用迭代器实现的，效率稍逊于for循环。


## 二十七、 IO与NIO

IO        |        NIO
:---: | :---
面向流       |     面向缓冲
阻塞IO        |    非阻塞IO
无            |    选择器


## 二十八、  反射的作用与原理

什么是Java的反射：
>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。

大家都知道，要让Java程序能够运行，那么就得让Java类要被Java虚拟机加载。Java类如果不被Java虚拟机加载，是不能正常运行的。现在我们运行的所有的程序都是在编译期的时候就已经知道了你所需要的那个类的已经被加载了。
<br>
Java的反射机制是在编译并不确定是哪个类被加载了，而是在程序运行的时候才加载、探知、自审。使用在编译期并不知道的类。这样的特点就是反射。

作用：
>假如我们有两个程序员，一个程序员在写程序的时候，需要使用第二个程序员所写的类，但第二个程序员并没完成他所写的类。那么第一个程序员的代码能否通过编译呢？这是不能通过编译的。利用Java反射的机制，就可以让第一个程序员在没有得到第二个程序员所写的类的时候，来完成自身代码的编译。
<br>
Java的反射机制它知道类的基本结构，这种对Java类结构探知的能力，我们称为Java类的“自审”。大家都用过Jcreator和eclipse。当我们构建出一个对象的时候，去调用该对象的方法和属性的时候。一按点，编译工具就会自动的把该对象能够使用的所有的方法和属性全部都列出来，供用户进行选择。这就是利用了Java反射的原理，是对我们创建对象的探知、自审。

代码示例：
```
package thread;

import java.lang.reflect.Field;
import java.lang.reflect.Method;

public class TestReflect {
	public TestReflect() {
		try {
			Class<?> myClass = TestClass.class;//这里可以指定任意类
			Method[] method  = myClass.getDeclaredMethods();
			
			for(Method met: method){
				System.out.println(met.toString());
			}
			
			System.out.println("************");
			
			Field[] field = myClass.getDeclaredFields();
			for(Field fi:field){
				System.out.println(fi.toString() + ":" + fi.getGenericType());
			}
			
		} catch (Exception e) {
			e.printStackTrace();
		}
	}
	
	public static void main(String[] args) {
		new TestReflect();
	}
}
class TestClass{
	private String testString = "testString";
	private int testInt = 23;
	private char testchar= 'b';
	
	
	public TestClass(String testString, int testInt, char testchar) {
		this.testString = testString;
		this.testInt = testInt;
		this.testchar = testchar;
	}
	
	public String getTestString() {
		return testString;
	}
	public void setTestString(String testString) {
		this.testString = testString;
	}
	public int getTestInt() {
		return testInt;
	}
	public void setTestInt(int testInt) {
		this.testInt = testInt;
	}
	public char getTestchar() {
		return testchar;
	}
	public void setTestchar(char testchar) {
		this.testchar = testchar;
	}
	
}
```
 
##二十九、TCP三次握手四次挥手
**三次握手**：
>1. 第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。
2. 第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN_RECV状态。
3. 第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。
完成三次握手，客户端与服务器开始传送数据。（TCP协议建立连接的三次握手过程中的第三次握手允许携带数据。）

**四次挥手**：

>1. 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 
2. 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 
3. 服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 
4. 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1。 

##三十、 线程进程的定义区

[博客解释](http://blog.csdn.net/yanxiaolx/article/details/51763372)

**一、进程**
>指在系统中能独立运行并作为资源分配的基本单位，它是由一组机器指令、数据和堆栈等组成的，是一个能独立运行的活动实。

 注：进程一般有三个状态：就绪状态、执行状态和等待状态【或称阻塞状态】；进程只能由父进程建立，系统中所有的进程形成一种进程树的层次体系；挂起命令可由进程自己和其他进程发出，但是解除挂起命令只能由其他进程发出。

进程控制块（PCB）：PCB不但可以记录进程的属性信息，以便操作系统对进程进行控制和管理，而且PCB标志着进程的存在，操作系统根据系统中是否有该进程的进程控制块PCB而知道该进程存在与否。系统建立进程的同时就建立该进程的PCB，在撤销一个进程时，也就撤销其PCB，故进程的PCB对进程来说是它存在的具体的物理标志和体现。一般PCB包括以下三类信息：进程标识信息；处理器状态信息；进程控制信息。由程序段、相关的数据段和PCB三部分构成了进程实体（又称进程印像），一般，我们把进程实体就简称为进程。

进程的特征：
>1. 动态性：进程的实质是程序的一次执行过程，进程是动态产生，动态消亡的。
2. 并发性：任何进程都可以同其他进程一起并发执行。
3. 独立性：进程是一个能独立运行的基本单位，同时也是系统分配资源和调度的独立单位。
4. 异步性：由于进程间的相互制约，使进程具有执行的间断性，即进程按各自独立的、不可预知的速度向前推进。

<br>
**二、线程**
>线程是进程中的一个实体，作为系统调度和分派的基本单位。

线程的性质：
1. 线程是进程内的一个相对独立的可执行的单元。若把进程称为任务的话，那么线程则是应用中的一个子任务的执行。
2. 由于线程是被调度的基本单元，而进程不是调度单元。所以，每个进程在创建时，至少需要同时为该进程创建一个线程。即进程中至少要有一个或一个以上的线程，否则该进程无法被调度执行。
3. 进程是被分给并拥有资源的基本单元。同一进程内的多个线程共享该进程的资源，但线程并不拥有资源，只是使用他们。
4. 线程是操作系统中基本调度单元，因此线程中应包含有调度所需要的必要信息，且在生命周期中有状态的变化。
5. 由于共享资源【包括数据和文件】，所以线程间需要通信和同步机制，且需要时线程可以创建其他线程，但线程间不存在父子关系。


多线程使用的情形：前台和后台工作情况；异步处理工作情况；需要加快执行速度情况；组织复杂工作的情况；同时有多个用户服务请求的情况等。
 
线程机制的优点：
>多线程运行在同一个进程的相同的地址空间内，和采用多进程相比有以下优点：
1. 创建和撤销线程的开销较之进程要少。创建线程时只需要建立线程控制表相应的表目，或有关队列，而创建进程时，要创建PCB表和初始化，进入有关进程队列，建立它的地址空间和所需资源等。
2. CPU在线程之间开关时的开销远比进程要少得多。因开关线程都在同一地址空间内，只需要修改线程控制表或队列，不涉及地址空间和其他工作。
3. 线程机制也增加了通讯的有效性。进程间的通讯往往要求内核的参与，以提供通讯机制和保护机制，而线程间的通讯是在同一进程的地址空间内，共享主存和文件，无需内核参与。

**三、进程和线程的区别**

（1）调度：
在传统的操作系统中，CPU调度和分派的基本单位是进程。而在引入线程的操作系统中，则把线程作为CPU调度和分派的基本单位，进程则作为资源拥有的基本单位，从而使传统进程的两个属性分开，线程编程轻装运行，这样可以显著地提高系统的并发性。同一进程中线程的切换不会引起进程切换，从而避免了昂贵的系统调用，但是在由一个进程中的线程切换到另一进程中的线程，依然会引起进程切换。
 
（2）并发性：
      在引入线程的操作系统中，不仅进程之间可以并发执行，而且在一个进程中的多个线程之间也可以并发执行，因而使操作系统具有更好的并发性，从而更有效地提高系统资源和系统的吞吐量。例如，在一个为引入线程的单CPU操作系统中，若仅设置一个文件服务进程，当它由于某种原因被封锁时，便没有其他的文件服务进程来提供服务。在引入线程的操作系统中，可以在一个文件服务进程设置多个服务线程。当第一个线程等待时，文件服务进程中的第二个线程可以继续运行；当第二个线程封锁时，第三个线程可以继续执行，从而显著地提高了文件服务的质量以及系统的吞吐量。


（3）拥有资源：
      不论是引入了线程的操作系统，还是传统的操作系统，进程都是拥有系统资源的一个独立单位，他可以拥有自己的资源。一般地说，线程自己不能拥有资源（也有一点必不可少的资源），但它可以访问其隶属进程的资源，亦即一个进程的代码段、数据段以及系统资源（如已打开的文件、I/O设备等），可供同一个进程的其他所有线程共享。


（4）独立性：
        在同一进程中的不同线程之间的独立性要比不同进程之间的独立性低得多。这是因为

为防止进程之间彼此干扰和破坏，每个进程都拥有一个独立的地址空间和其它资源，除了共享全局变量外，不允许其它进程的访问。但是同一进程中的不同线程往往是为了提高并发性以及进行相互之间的合作而创建的，它们共享进程的内存地址空间和资源，如每个线程都可以访问它们所属进程地址空间中的所有地址，如一个线程的堆栈可以被其它线程读、写，甚至完全清除。


（5）系统开销：
由于在创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O设备等。因此，操作系统为此所付出的开销将显著地大于在创建或撤消线程时的开销。类似的，在进程切换时，涉及到整个当前进程CPU环境的保存环境的设置以及新被调度运行的CPU环境的设置，而线程切换只需保存和设置少量的寄存器的内容，并不涉及存储器管理方面的操作，可见，进程切换的开销也远大于线程切换的开销。此外，由于同一进程中的多个线程具有相同的地址空间，致使他们之间的同步和通信的实现也变得比较容易。在有的系统中，现成的切换、同步、和通信都无需操作系统内核的干预。


（6）支持多处理机系统：
       在多处理机系统中，对于传统的进程，即单线程进程，不管有多少处理机，该进程只能运行在一个处理机上。但对于多线程进程，就可以将一个进程中的多个线程分配到多个处理机上，使它们并行执行，这无疑将加速进程的完成。因此，现代处理机OS都无一例外地引入了多线程。

## 三十一、输入网址的整个过程
1）把URL分割成几个部分：协议、网络地址、资源路径。其中网络地址指示该连接网络上哪一台计算机，可以是域名或者IP地址，可以包括端口号；协议是从该计算机获取资源的方式，常见的是HTTP、FTP，不同协议有不同的通讯内容格式；资源路径指示从服务器上获取哪一项资源。
例如：http://www.zhihu.com/question/554991/
协议部分：http
网络地址：www.guokr.com
资源路径：/question/554991/

2）如果地址不是一个IP地址，通过DNS（域名系统）将该地址解析成IP地址。IP地址对应着网络上一台计算机，DNS服务器本身也有IP，你的网络设置包含DNS服务器的IP。
例如：www.zhihu.com 不是一个IP，向DNS询问请求www.zhihu.com 对应的IP，获得IP： 111.13.57.142。这个过程里，你的电脑直接询问的DNS服务器可能没有www.zhihu.com 对应的IP，就会向它的上级服务器询问，上级服务器同样可能没有，就依此一层层向上找，最高可达根节点，找到或者全部找不到为止。

3）如果地址不包含端口号，根据协议的默认端口号确定一个。端口号之于计算机就像窗口号之于银行，一家银行有多个窗口，每个窗口都有个号码，不同窗口可以负责不同的服务。端口只是一个逻辑概念，和计算机硬件没有关系。
例如：www.guokr.com 不包含端口号，http协议默认端口号是80。如果你输入的url是http://wwwzhihu.com:8080/ ，那表示不使用默认的端口号，而使用指定的端口号8080。

4）向2和3确定的IP和端口号发起网络连接。
例如：向111.13.57.142的80端口发起连接

5）根据http协议要求，组织一个请求的数据包，里面包含大量请求信息，包括请求的资源路径、你的身份
例如：用自然语言来表达这个数据包，大概就是：请求 /question/554991/ ，我的身份是xxxxxxx。

6）服务器响应请求，将数据返回给浏览器。数据可能是根据HTML协议组织的网页，里面包含页面的布局、文字。数据也可能是图片、脚本程序等。现在你可以用浏览器的“查看源代码”功能，感受一下服务器返回的是什么东东。如果资源路径指示的资源不存在，服务器就会返回著名的404错误。

7）如果（6）返回的是一个页面，根据页面里一些外链的URL，例如图片的地址，按照（1）－（6）再次获取。

8）开始根据资源的类型，将资源组织成屏幕上显示的图像，这个过程叫渲染，网页渲染是浏览器最复杂、最核心的功能。

9）将渲染好的页面图像显示出来，并开始响应用户的操作。

## 三十二、计算机网络的五层及其主要功
1. 应用层
>应用层为应用程序提供网络服务

2. 传输层
>传输层负责向用户提供端到端的通信服务，实现流量控制以及差错控制；

3. 网络层
>网络层主要负责创建逻辑链路，以及实现数据包的分片和重组，实现拥塞控制、网络互连等功能；

4. 数据链路层
>数据链路层主要负责在通信的实体间建立数据链路连接；

5. 物理层
>物理层主要负责在物理线路上传输原始的二进制数据；

##三十三、操作系统的分页算法
（银行家算法：避免死锁的，基本思想是有资源才会进行分配）


##三十四、各种排序思想机器时间复杂度
[我的GIT](https://github.com/snail-lb/DataStructure)

1. 冒泡排序
   两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录为止。

2. 选择排序
    简单选择排序法（Simple Selection Sort）就是通过n-i次关键字间的比较，从n-i+1个记录中选出关键字最小的记录，并和第i(1≤i≤n)个记录交换之。

3. 插入排序
直接插入排序（Straight Insertion Sort）的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表。

4. 希尔排序
我们将原本有大量记录数的记录进行分组。分割成若干个子序列，此时每个子序列待排序的记录个数就比较少了，然后在这些子序列内分别进行直接插入排序，当整个序列都基本有序时，注意只是基本有序时，再对全体记录进行一次直接插入排序。

5. 堆排序 
堆排序（Heap Sort）就是利用堆（假设利用大顶堆）进行排序的方法。它的基本思想是，将待排序的序列构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根结点。将它与堆数组的末尾元素进行交换，此时末尾元素就是最大值，然后将剩余的n-1个序列重新构造成一个堆，这样就会得到n个元素中的次小值。如此反复执行，便能得到一个有序序列了。（大顶堆：在完全二叉树中，每个结点的值都大于或等于其左右孩子结点的值）


6. 归并排序
归并排序（Merging Sort）就是利用归并的思想实现的排序方法。它的原理是假设初始序列含有n个记录，则可以看成是n个有序的子序列，每个子序列的长度为1，然后两两归 并，得到⌈n/2⌉（⌈x⌉表示不小于x的最小整数）个长度为2的有序子序列；再两两归并，……     如此重复，直至得到一个长度为n的有序序列为止，这 种排序方法称为2路归并排序。


7. 快速排序
快速排序（Quick Sort）的基本思想是通过一趟排序将待排记录分割成独立的两部分，其中一部分记录的关键字均比另一部分记录的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序的目的。


[时间复杂度比较](http://blog.chinaunix.net/uid-21457204-id-3060260.html)

##三十五、javaIO的包装
[IO结构](http://www.cnblogs.com/LittleHann/p/3678685.html)


##三十六、二叉树最小深度算法
[我的GIT](https://github.com/snail-lb/DataStructure)

##三十七、概率论复习
[概率论](http://noalgo.info/414.html)

##三十八、数据库多表连接查询基本概念
[博客地址](http://www.cnblogs.com/devilmsg/archive/2009/03/24/1420543.html)
[博客](http://www.cnblogs.com/Ewin/archive/2009/10/05/1578322.html)
[数据库常见面试题](http://blog.sina.com.cn/s/blog_8dc50331010158u7.html)
1、内连接查询 
采用内连接计算的时候必须要保证连接的条件相匹配，结果才会被检索出来
select   a.\*,b.*   from   a   inner   join   b     on   a.id=b.parent_id       

2、左外联结 
但是有些情况下，我们需要知道所有员工的信息，即使他不属于任何部门。这样我们就可以采用外连接，在这里为左外连接，也就是连接中的左表的表中的记录，无论能不能在右表中找到匹配的项，都要检索，如果没有匹配的项目，那么右表中的字段值为NULL（空），在这里就代表，此员工不属于任何部门。 
select a.\*,b.* from a left join b on a.id=b.id;

3、右外连接 
有时，我们需要知道，全部部门的信息，即使它没有任何的员工。在我们的查询中部门表在连接的右边，如果我们想知道右边表中的所有记录信息，那么就可以采用右外连接，如果此记录在左边的表中找不到匹配项，则相应字段（employeeid,employeename)为NULL 
select a.\*,b.* from a right join b on a.id=b.id;


##三十九、xml常见的解析技术
[博客](http://blog.csdn.net/jzhf2012/article/details/8532873)

1）DOM(JAXP Crimson解析器) 应用于多种编程语言
DOM是用与平台和语言无关的方式表示XML文档的官方W3C标准。

2）SAX
 SAX处理的优点非常类似于流媒体的优点。分析能够立即开始，而不是等待所有的数据被处理。而且，由于应用程序只是在读取数据时检查数据，因此不需要将数据存储在内存中。
 
3）JDOM
 JDOM的目的是成为Java特定文档模型，它简化与XML的交互并且比使用DOM实现更快。
 
4）DOM4J  性能最好

##四十、 jdbc调用流程（贾琏欲执事）
1.加载驱动
2.获取连接
3.SQL语句
4.执行SQL
5.释放资源

1、执行静态SQL语句。通常通过Statement实例实现。    2、执行动态SQL语句。通常通过PreparedStatement实例实现。         
3、执行数据库存储过程。通常通过CallableStatement实例实现。      

jdbc实现事务：
```
 //设置事务的提交方式为非自动提交：

              con.setAutoCommit(false);

              //将需要添加事务的代码一同放入try，catch块中

 

                  //创建执行语句

                  String sql ="delete from me where id = 7";

                  String sql1 = "update me set name ='chengong' ,age ='34' where id =4";

                  //分别执行事务

                  ps = con.prepareStatement(sql);

                  ps.executeUpdate();

                  ps = con.prepareStatement(sql1);

                  ps.executeUpdate();

                  

                  //在try块内添加事务的提交操作，表示操作无异常，提交事务。

 

                  con.commit();

                 

              } catch (SQLException e) {

              try {

                  //.在catch块内添加回滚事务，表示操作出现异常，撤销事务：

                  con.rollback();

              } catch (SQLException e1) {

                  // TODO Auto-generatedcatch block

                  e1.printStackTrace();

              }

                  e.printStackTrace();

              }finally{

                  try {

                     //设置事务提交方式为自动提交：

                     con.setAutoCommit(true);

                  } catch (SQLException e) {

                     // TODO Auto-generatedcatch block

                     e.printStackTrace();

                  }

                  DBCManager.release(rs, ps, con);

              }
```

##四十、Tomcat
TOMCAT的目录结构

    /bin：存放windows或Linux平台上启动和关闭Tomcat的脚本文件
    /conf：存放Tomcat服务器的各种全局配置文件，其中最重要的是server.xml和web.xml
    /doc：存放Tomcat文档
    /server：包含三个子目录：classes、lib和webapps
    /server/lib：存放Tomcat服务器所需的各种JAR文件
    /server/webapps：存放Tomcat自带的两个WEB应用admin应用和 manager应用
    /common/lib：存放Tomcat服务器以及所有web应用都可以访问的jar文件
    /shared/lib：存放所有web应用都可以访问的jar文件（但是不能被Tomcat服务器访问）
    /logs：存放Tomcat执行时的日志文件
    /src：存放Tomcat的源代码
    /webapps：Tomcat的主要Web发布目录，默认情况下把Web应用文件放于此目录
    /work：存放JSP编译后产生的class文件

WEB应用的目录结构：假设在$CATALINA_HOME/webapps下有helloapp的web应用

    /helloapp：Web应用的根目录，所有的jsp文件和html文件都在此目录下
    /helloapp/WEB_INF：存放该web应用发布时的描述文件web.xml
    /helloapp/WEB_INF/class：存放各种class文件，Servlet文件也存放于此目录下
    /helloapp/WEB_INF/lib：存放各钟Web应用所需要的jar文件。比如可以存放JDBC驱动程序的JAR文件

Tomcat加载类和资源的顺序为（以helloapp应用为例）

    helloapp      （/webapps/helloapp/Web-INF/下的classes，lib子目录中*.calss及*.jar，仅helloapp可以加载）
    Bootstrap     （$JAVA_HOME/jre/lib/ext/*.jar）
    System        （$CLASSPATH/*.class和CLASSPATH中指定的jar）
    Common        （$CATALINA_HOME/common/下的classes，lib，endores子目录中*.class及*.jar）
    Catalina      （$CATALINA_HOME/server/下的classes，lib子目录中*.calss及*.jar，仅Tomcat可以加载）
    Shared        （$CATALINA_HOME/shared/下的classes，lib子目录中*.calss及*.jar，仅所有Web应用可以加载）

把一个web应用部署到tomcat下的几种方法：
    >  第一种方法：在tomcat中的conf目录中，在server.xml中的，<host/>节点中添加：
<Context path="/hello"
docBase="D:\eclipse3.2.2forwebtools\workspace\hello\WebRoot" debug="0"
privileged="true">
</Context> 
至于Context 节点属性，可详细见相关文档。 

>第二种方法：将web项目文件件拷贝到webapps 目录中。 

>第三种方法：很灵活，在conf目录中，新建
Catalina（注意大小写）＼localhost目录，在该目录中新建一个xml文件，名字可以随意取，只要和当前文件中的文件名不重复就行了，该xml文件的内容为：
<Context path="/hello"
docBase="D:\eclipse3.2.2forwebtools\workspace\hello\WebRoot" debug="0"
privileged="true">
</Context>
第3个方法有个优点，可以定义别名。服务器端运行的项目名称为path，外部访问的URL则使用XML的文件名。这个方法很方便的隐藏了项目的名称，对一些项目名称被固定不能更换，但外部访问时又想换个路径，非常有效。

##四十一、线程
当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?
分几种情况：
     1.其他方法前是否加了synchronized关键字，如果没加，则能。
     2.如果这个方法内部调用了wait，则可以进入其他synchronized方法。
     3.如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。
     4.如果其他方法是static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是this。
     
创建线程的方法：
1. 继承Thread
2. 实现Runable接口
3. 实现Callable接口（有返回值的线程的创建）
4. 线程池


## 四十二、接口和抽象类的区别


## 四十三、Comparable 和 Comparator 接口的作用
Comparable接口中只包含了一个compareTo(T o)方法，这个方法用来比较此对象与指定对象的顺序。

Comparator接口中包含了compare(T a1,T a2)和equals(Object obj)两个方法。compare(T a1,T a2)方法用来给两个输入参数排序。equals(Object o)用来指示某个其他对象是否“等于”此 Comparator。

##四十四、java中的参数传递-值传递|引用传递
1. 对象就是传引用
2. 原始类型就是传值
3. String类型可以认为是传值。String就相当于是char[]的包装类。包装类的特质之一就是在对其值进行操作时会体现出其对应的基本类型的性质。在参数传递时，包装类就是如此体现的。所以，对于String在这种情况下的展现结果的解释就自然而然得出了。


##四十五、反转字符串
1. 使用字符数组进行反转。（循环赋值是最好前后同时进行赋值）
2. 使用栈进行反转。（先将字符串转为字符数组进行入栈，然后出栈得到反转后的字符串）
3. 使用StringBuffer中的reverse()反转方法可直接实现。

##四十六、不使用中间变量交换两个数或者两个字符
```
public  class Test {
	public static void main(String[] args){
		char a = 'a';
		char b = 'c';
		a = (char) (a^b);
		b = (char) (b^a);
		a = (char) (b^a);
		System.out.println("a:" + a + "  b:" + b);
		
		int x = 1;
		int y = 5;
		x = x^y;
		y = y^x;
		x = y^x;
		System.out.println("x:" + x + "  y:" + y);
		
	}
}
```
运行结果：
>a:c  b:a
x:5  y:1

##四十七、获取一个文件中单词出现的最高频率
[出处](http://www.voidcn.com/blog/jocelynyoung/article/p-2493920.html)
1. 读取被测文本文件，采用缓冲流的方式读取。
2. 利用replace函数将标点符号去除。
3. 将处理过的单词存入字典树中。
4. 文本全部读取完之后开始使用字典树遍历。
5. 采用深度优先的方式读取每个单词的词频，最先利用TreeMap<String, Integer>存储10个单词，单词-频数作为键值对。
6. 使用TopK算法思想，从第11个单词之后遍历出来的单词频数跟Top10中词频数最小的单词比较，如果大于Top10里面的最小值，则替换Top10里面的。使用TopK算法思想可以避免存储空间的浪费。
7. 全部遍历完全之后，对Top10里面的单词进行排序，这里需要重写比较器，最后输出词频数前10的单词。

##四十八、int Integer 比较大小
①无论如何，Integer与new Integer不会相等。不会经历拆箱过程， 
②两个都是非new出来的Integer，如果数在-128到127之间，则是true,否则为false  java在编译Integer i2 = 128的时候,被翻译成-> Integer i2 = Integer.valueOf(128);而valueOf()函数会对-128到127之间的数进行缓存 
③两个都是new出来的,都为false 
④int和integer(无论new否)比，都为true，因为会把Integer自动拆箱为int再去比


##四十九、各种二叉树概念

**满二叉树**：  
>深度为k，有 2^k - 1 个节点的二叉树。

**完全二叉树**：
>深度为k，有n个节点的二叉树，当且仅当其每个节点都与深度为k的满二叉树编号从1至n的节点一一对应时称为完全二叉树。
具有n各节点的完全二叉树的深度为$$log_2 n + 1$$ 

**最优二叉树(哈夫曼树)**
>给定n个权值作为n个叶子结点，构造一棵二叉树，若带权路径长度达到最小，称这样的二叉树为最优二叉树，也称为哈夫曼树(Huffman Tree)。哈夫曼树是带权路径长度最短的树，权值较大的结点离根较近。

**平衡二叉树(AVL树)**
>它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。

**二叉排序树（二叉查找树，二叉搜索树）**
>二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：
（1）若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值；
（2）若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；
（3）左、右子树也分别为二叉排序树；

**红黑树**
>红黑树 是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。
对于任何有效的红黑树需要具有以下性质：
1. 节点是红色或黑色。
2. 根节点是黑色。
3 每个叶节点（NIL节点，空节点）是黑色的。
4 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。

**二叉堆**
>二叉堆是一种特殊的堆，二叉堆是完全二元树（二叉树）或者是近似完全二元树（二叉树）。
最大堆：父结点的键值总是大于或等于任何一个子节点的键值；
最小堆：父结点的键值总是小于或等于任何一个子节点的键值。

**二叉树常见操作：**
[博客传送门](http://blog.csdn.net/luckyxiaoqiang/article/details/7518888)

##五十、 浅谈AJAX原理
 Ajax的原理就是:通过javascript的方式，将前台数据通过xmlhttp对象传递到后台，后台在接收到请求后，将需要的结果，再传回到前台，这样就可以实现不需要页面的回发，页是数据实现来回传递，从页实现无刷新。 
    Ajax的原理简单来说，实际上就是通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。 
这其中最关键的一步就是从服务器获得请求数据。要清楚这个过程和原理，我们必须对 XMLHttpRequest有所了解。 
    我们可以看出，XMLHttpRequest对象完全用来向服务器发出一个请求的，它的作用也局限于此，但它的作用是整个ajax实现的关键，我们可以把服务器端看成一个数据接口，它返回的是一个纯文本流，当然，这个文本流可以是XML格式，可以是Html，可以是Javascript代码，也可以只是一个字符串。这时候，XMLHttpRequest向服务器端请求这个页面，服务器端将文本的结果写入页面，这和普通的web开发流程是一样的，不同的是，客户端在异步获取这个结果后，不是直接显示在页面，而是先由javascript来处理，然后再显示在页面。





##五十一、JVM 内存分哪几个区，及其作用

java 虚拟机主要分为以下一个区 :

**A.方法区(线程共享)：** 
>1. 有时候也成为 永久代 ，在该区内很少发生垃圾回收，但是并不代表不发生 GC ，在这里进行的 GC 主要是对方法区里的常量池和对类型的卸载 
2. 方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。
3. 该区域是被线程共享的。 
4. 方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。

**B.堆（线程共享）** 
>java 堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。

**C.本地方法栈（线程独享）** 
>本地方法栈和虚拟机栈类似，只不过本地方法栈为 Native 方法服务。

**D.虚拟机栈（线程独享） :** 
>1. 虚拟机栈也就是我们平常所称的 栈内存 , 它为 java 方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。 
2. 虚拟机栈是线程私有的，它的生命周期与线程相同。 
3. 局部变量表里存储的是基本数据类型、 returnAddress 类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定 
4. 操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式 
5. 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接 . 动态链接就是将常量池中的符号引用在运行期转化为直接引用。

**E.程序计数器（线程独享）** 
>内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个 java 虚拟机规范没有规定任何 OOM 情况的区域。

##五十二. 如和判断一个对象是否存活 ?( 或者 GC 对象的判定方法 )

判断一个对象是否存活有两种方法 :

**A.  引用计数法** 
>所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是 “ 死对象 ”, 将会被垃圾回收 .
引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象 A 引用对象 B ，对象 B 又引用者对象 A ，那么此时 A,B 对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。

**B. 可达性算法 ( 引用链法 )**
>该算法的思想是：从一个被称为 GC Roots 的对象开始向下搜索，如果一个对象到 GC Roots 没有任何引用链相连时，则说明此对象不可用。<br> 
在 java 中可以作为 GC Roots 的对象有以下几种 :

>* 虚拟机栈中引用的对象
* 方法区类静态属性引用的对象
* 方法区常量池引用的对象
* 本地方法栈 JNI 引用的对象

虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象不一定会被回收 。当一个对象不可达 GC Root 时，这个对象并 不会立马被回收 ，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记 .
如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法或者已被虚拟机调用过，那么就认为是没必要的。 
如果该对象有必要执行 finalize() 方法，那么这个对象将会放在一个称为 F-Queue 的对队列中，虚拟机会触发一个 Finalize() 线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果 finalize() 执行缓慢或者发生了死锁，那么就会造成 F-Queue 队列一直等待，造成了内存回收系统的崩溃。 GC 对处于 F-Queue 中的对象进行第二次被标记，这时，该对象将被移除 `即将回收` 集合，等待回收。

##五十三、 简述 java 垃圾回收机制 ?

在 java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。

##五十四、java 中垃圾收集的方法有哪些 ?

1. 标记 - 清除 : 
>这是垃圾收集算法中最基础的，根据名字就可以知道，它的思想就是标记哪些要被回收的对象，然后统一回收。这种方法很简单，但是会有两个主要问题： 
>* 效率不高，标记和清除的效率都很低； 
>* 会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次 GC动作。

2. 复制算法 : 
>为了解决效率问题，复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，然后一次性清楚完第一块内存，再将第二块上的对象复制到第一块。
但是这种方式，内存的代价太高，每次基本上都要浪费一半的内存。 
于是将该算法进行了改进，内存区域不再是按照 1 ： 1 去划分，而是将内存划分为 8:1:1 三部分，较大那份内存交 Eden 区，其余是两块较小的内存区叫 Survior 区。每次都会优先使用 Eden 区，若 Eden 区满，就将对象复制到第二块内存区上，然后清除 Eden 区，如果此时存活的对象太多，以至于 Survivor 不够时，会将这些对象通过分配担保机制复制到老年代中。 (java 堆又分为新生代和老年代 )

3. 标记 - 整理 
>该算法主要是为了解决标记 -清除，产生大量内存碎片的问题；当对象存活率较高时，也解决了复制算法的效率问题。它的不同之处就是在清除对象的时候现将存活对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。 

4. 分代收集   
>现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用 `复制算法`。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用 `标记-整理`   或者   `标记-清除` 。

##五十五、创建一个泛型数组
```
E[] e = (E[])Array.newInstance(t.getClass(), 0);//创建t的当前泛型类
```
##五十六、两个浮点数比较大小
两个浮点数比较大小不能使用==
例如
```
public class Test7{
	public static void main(String[] args){
		float a = 1.23f;
		double b = 1.23;
		System.out.println(a==b);   //false
		System.out.println(Math.abs(a-b) < 0.000001); //true
	}
}
```
两个浮点数特别是float和double比较大小最好采用差值比较，因为浮点数都不是精确表示的，而是使用近似值进行表示的。

## 五十七、java海量数据处理
[博客](http://blog.csdn.net/v_july_v/article/details/6279498)

个人总结：
>1. 大量数据中找出最大的n个数：
    可以将文件分为k个，对每个小文件使用小顶堆找出每个小文件的最大的数。然后再在k个文件中找出最大的n个数。（这个数据结构也可以使用快排的思路在k个文件中找出最大的n个数找出）。
    
>2. 大量数据中找出出现频次最高的n个数
    s

>3. 大量数据进行排序
    可以采用外部归并排序。
    
>4. 两个文件中有大量数据，找出相同数据
    按照数据的位数进行分割，（如果按照位数进行分割后依旧很大，可以再按照首写字母或者结尾字母再次进行分割），这样就可以在分割后的小文件中进行比对查找出相同字符串的数据。

>5. 判断某个数是否存在于某个大数据文件中
    将这个数
    
## 五十八、 int和String相互转换的几种方法

```
int a = 1234;

String str1 = "" + a;
String str2 = Integer.toString(a);
String str3 = String.valueOf(a);
```
```
String str = "1234";

int x1 = Integer.valueOf(s).intValue();
int x2 = Integer.parseInt(s);
```

##五十九 、java异常
[Java异常](http://blog.csdn.net/hguisu/article/details/6155636)

##六十、 java随机数
java.lang.Math.random()  产生的是[0,1）的double随机数。
使用这个函数产生一个[min,max]  (min < max) :
`int num = min + (int)(Math.random() * (max-min+1));`


java.util.Random.nextInt(n) 产生的是[0,n)之间的随机整数
使用这个函数产生一个[min,max]  (min < max) :
`int num = min + (Random.nextInt(max-min+1));`

##六十一、 遍历Map
[java遍历Map的四种方法](http://blog.csdn.net/tjcyjd/article/details/11111401)
```
for(Map.Entry<String, String> m : map.entrySet()){
			System.out.println(m.getKey() + " :" + m.getValue());
		}
```

杂记：
原码：符号位加上真值的绝对值。
【+1】原码 = 0000 0001
【-1】原码 = 1000 0001

反码：正数的反码是其本身
负数的反码实在原码的基础上，符号位不变，其余各个位取反。
【+1】反码 = 0000 0001
【-1】反码 = 1111 1110

补码：正数的补码就是其本身
负数的补码是其在原码的基础上符号位不变，其余各位取反，最后+1（反码基础上加以）
【+1】补码 = 0000 0001
【-1】补码 = 1111 1111

if（） 条件语句中boolean类型的可以使用赋值语句
boolean s = false;
if（s = true）{}不会产生编译错误